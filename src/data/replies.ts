import {
    ChannelType,
    ColorResolvable,
    EmbedBuilder,
    Guild,
    GuildMember,
    PermissionsString,
    TextChannel,
    User
} from 'discord.js';
import errors from '../maps/errors';
import { moduleType, tasks } from '../typings/database';
import { permType } from '../typings/functions';
import { getRolePerm, moduleName, util } from '../utils/functions';
import {
    addTimeDoc,
    anyHexColor,
    basicEmbed as basic,
    displayDate,
    evokerColor,
    notNull,
    numerize,
    pingChan,
    pingUser,
    plurial,
    random,
    resizeString
} from '../utils/toolbox';
import { color } from '../utils/functions';
import modules from '../maps/modules';
import { configKeys, configsData } from './configData';

export type anyUser = User | GuildMember;

const userMember = (user: anyUser, color?: ColorResolvable) => {
    const embed = basic(user instanceof User ? user : user.user).setColor(color ?? '#ff0000');
    if (user instanceof GuildMember) embed.setColor(evokerColor(user.guild));

    return embed;
};

const replies = {
    guildOnly: (user: User, metadata: { guild?: Guild }) => {
        return basic(user)
            .setTitle(':x: Serveur uniquement')
            .setDescription(`Cette commande n'est disponible que sur un serveur`)
            .setColor(evokerColor(metadata.guild));
    },
    DMOnly: (user: User, metadata: { guild?: Guild }) => {
        return basic(user)
            .setTitle(':x: Message priv√©s uniquement')
            .setDescription(`Cette commande n'est disponible qu'en messages priv√©s`)
            .setColor(evokerColor(metadata.guild));
    },
    clientMissingPermissions: (
        user: User,
        metadata: { permissions?: { missing: PermissionsString[] }; guild?: Guild }
    ) => {
        const { missing } = metadata.permissions;

        return basic(user)
            .setTitle(':x: Permissions insuffisantes')
            .setDescription(
                `Je n'ai pas les permissions n√©c√©ssaires pour √©x√©cuter cette commande.\n${
                    missing.length === 1
                        ? `V√©rifiez que j'aie bien la permission \`${getRolePerm(missing[0] as permType<'role'>)}\``
                        : `V√©rifiez que j'aie bien les permissions : ${missing
                              .map((perm) => `\`${getRolePerm(perm as permType<'role'>)}\``)
                              .join(' ')}`
                }`
            )
            .setColor(evokerColor(metadata.guild));
    },
    userMissingPermissions: (
        user: User,
        metadata: { permissions?: { missing: PermissionsString[] }; guild?: Guild }
    ) => {
        const { missing } = metadata.permissions;

        return basic(user)
            .setTitle(':x: Permissions insuffisantes')
            .setDescription(
                `Vous n'avez pas pas les permissions n√©c√©ssaires pour √©x√©cuter cette commande.\n${
                    missing.length === 1
                        ? `V√©rifiez que vous ayez bien la permission \`${getRolePerm(missing[0] as permType<'role'>)}\``
                        : `V√©rifiez que vous ayez bien les permissions : ${missing
                              .map((perm) => `\`${getRolePerm(perm as permType<'role'>)}\``)
                              .join(' ')}`
                }`
            )
            .setColor(evokerColor(metadata.guild));
    },
    underCooldown: (user: User, metadata: { remainingCooldownTime?: number; guild?: Guild }) => {
        return basic(user)
            .setTitle(':x: Cooldown')
            .setDescription(
                `Vous √™tes sous cooldown.\nMerci de patienter encore **${
                    Math.floor(metadata.remainingCooldownTime) / 1000
                } secondes**`
            )
            .setColor(evokerColor(metadata.guild));
    },
    moduleDisabled: (user: User, { guild, module }: { guild: Guild; module: moduleType }) => {
        const embed = basic(user)
            .setTitle(':x: Module d√©sactiv√©')
            .setDescription(`Le module \`${moduleName(module)}\` est d√©sactiv√©.`)
            .setColor(evokerColor(guild));

        const times = modules.get(user.id) ?? 0;
        if (times >= 5) {
            embed.setDescription(
                `${embed.data.description}\n\n:bulb:\n> Pour activer un module, utilisez la commande \`/module configurer\``
            );
        }
        modules.set(user.id, times + 1);
        return embed;
    },
    invalidProofType: (user: User, { guild }: { guild: Guild }) => {
        return basic(user)
            .setColor(evokerColor(guild))
            .setTitle(`:x: Preuve invalide`)
            .setDescription(`D√©sol√©, les preuves doivent √™tre sous format **image**`);
    },
    cancel: () => {
        return new EmbedBuilder().setTitle('üí° Annul√©').setColor('Yellow');
    },
    mysqlError: (user: User, metadata: { guild?: Guild }) => {
        let text = `Une erreur a eu lieu lors de l'interaction avec la base de donn√©es.\nPatientez quelques secondes et r√©essayez.`;
        if (errors.has(user.id)) {
            if (errors.get(user.id) > 3) {
                text += `\nSi l'erreur persiste, contactez mes d√©veloppeurs`;
            }
        }
        errors.set(user.id, (errors.get(user.id) ?? 0) + 1);
        return basic(user).setColor(evokerColor(metadata.guild)).setDescription(text).setTitle('Erreur');
    },
    memberOwner: (user: User, { member }: { member: GuildMember }) => {
        return basic(user)
            .setColor(evokerColor(member.guild))
            .setTitle('Membre propri√©taire')
            .setDescription(`Vous ne pouvez pas faire √ßa, car ${member} est le propri√©taire du serveur`);
    },
    memberBot: (user: User, { member }: { member: GuildMember }) => {
        return basic(user)
            .setColor(evokerColor(member.guild))
            .setTitle('Robot')
            .setDescription(`${member} est un robot. Je ne peux pas effectuer cette action sur un robot`);
    },
    memberTooHigh: (user: User, { member }: { member: GuildMember }) => {
        return basic(user)
            .setColor(evokerColor(member.guild))
            .setTitle('Membre trop haut')
            .setDescription(`${member} est sup√©rieur ou √©gal √† vous dans la hi√©ararchie des r√¥les`);
    },
    memberTooHighClient: (user: User, { member }: { member: GuildMember }) => {
        return basic(user)
            .setTitle('Membre trop haut')
            .setDescription(`${member} est sup√©rieur ou √©gal √† moi dans la hi√©rarchie des r√¥les`)
            .setColor(evokerColor(member.guild));
    },
    notEnoughCoins: (user: GuildMember, target = user) => {
        return basic(user.user)
            .setTitle(`Pas assez ${util('coinsPrefix')}`)
            .setDescription(
                `${target.id === user.id ? "Vous n'avez" : `${target} n'a`} pas assez ${util(
                    'coinsPrefix'
                )} pour faire √ßa`
            )
            .setColor(evokerColor(user.guild));
    },
    selfMod: ({ user, guild }: GuildMember, metadata: any) => {
        return basic(user)
            .setTitle(`Auto-mod√©ration`)
            .setDescription(`Vous ne pouvez pas faire √ßa sur vous-m√™me`)
            .setColor(evokerColor(guild));
    },
    replyNotAllowed: (user: anyUser) => {
        return userMember(user)
            .setTitle('Interaction non-autoris√©e')
            .setDescription(`Vous n'√™tes pas autoris√© √† interagir avec ce message`);
    },
    unexistingLog: (user: anyUser, id: string) => {
        return userMember(user)
            .setTitle('Log inexistant')
            .setDescription(`Le log d'identifiant \`${id}\` n'existe pas sur ce serveur.`);
    },
    deletedLog: (user: anyUser, id: string) => {
        return userMember(user)
            .setTitle('Log supprim√©')
            .setDescription(
                `Le log d'identifiant \`${id}\` est supprim√©.\nVous ne pouvez pas faire √ßa sur un log supprim√©`
            );
    },
    ownerOnly: (user: User, { guild }: { guild: Guild }) => {
        return basic(user)
            .setColor(evokerColor(guild))
            .setTitle('Propri√©taire uniquement')
            .setDescription(`Cette commande est r√©serv√©e au propri√©taire du serveur`);
    },
    interserverAlreadySet: (user: anyUser, metadata: { channel_id: string }) => {
        return userMember(user)
            .setTitle('Salon d√©j√† configur√©')
            .setDescription(`Le salon ${pingChan(metadata.channel_id)} est d√©j√† un salon d'interchat`);
    },
    interserverUnexistingFrequence: (user: anyUser, { frequence }: { frequence: string }) => {
        return userMember(user)
            .setTitle('Fr√©quence invalide')
            .setDescription(`La fr√©quence \`${frequence}\` n'est utilis√©e dans aucun autre serveur`);
    },
    interserverFrequenceAssigned: (user: anyUser, { frequence }: { frequence: string }) => {
        return userMember(user)
            .setTitle('Fr√©quence d√©j√† utilis√©e')
            .setDescription(`Cette fr√©quence est d√©j√† utilis√©e dans un autre salon du serveur`);
    },
    interserverWebhookFailed: (user: anyUser, metadata: object) => {
        return userMember(user)
            .setTitle('Pas de webhook')
            .setDescription(
                `Je n'ai pas pu cr√©er de webhook.\nV√©rifiez que je poss√®de la permission \`g√©rer les webhooks\` et r√©essayez`
            );
    },
    interserverNoFrequence: (user: anyUser, metadata: object) => {
        return userMember(user)
            .setTitle('Pas de fr√©quence')
            .setDescription(
                `Vous n'√™tes pas cens√© voir ce message.\nCette erreur arrive lorsque je n'ai pas r√©ussi √† g√©n√©rer une fr√©quence unique pour votre salon.\nUne des solutions est de r√©essayer la commande`
            );
    },
    interserverNotChannel: (user: anyUser, metadata: { channel: TextChannel }) => {
        return userMember(user)
            .setTitle('Salon invalide')
            .setDescription(`Le salon ${pingChan(metadata.channel)} n'est pas un salon d'interchat`);
    },
    wait: (user: User) => {
        return basic(user)
            .setTitle('Patientez...')
            .setDescription(`Merci de patienter quelques instants`)
            .setColor('Orange');
    },
    invalidNumber: (user: anyUser) => {
        return userMember(user)
            .setTitle('Nombre invalide')
            .setDescription(`Merci de saisir un nombre valide, sup√©rieur √† 0`);
    },
    invalidTime: (user: anyUser) => {
        return userMember(user)
            .setTitle('Temps invalide')
            .setDescription(`Vous n'avez pas saisi une dur√©e valide${addTimeDoc(user.id)}`);
    },
    invalidColor: (user: anyUser) => {
        return userMember(user)
            .setTitle('Couleur invalide')
            .setDescription(
                `Vous n'avez pas saisi une couleur valide.\nVoici quelques exemples de couleurs valides :\n\`${anyHexColor(
                    { hashtagIncluded: false, type: 'long' }
                )}\`\n\`${anyHexColor({ hashtagIncluded: true, type: 'long' })}\`\n\`${anyHexColor({
                    type: 'short',
                    hashtagIncluded: true
                })}\``
            );
    },
    loto: {
        noCurrentLoto: (user: User, guild: Guild) =>
            userMember(user)
                .setColor(evokerColor(guild))
                .setTitle('Loto inexistant')
                .setDescription(`Il n'y a aucun giveaway en cours sur ce serveur`),
        participationRegistered: (user: User) =>
            userMember(user)
                .setColor(util<ColorResolvable>('accentColor'))
                .setTitle('Participation enregistr√©e')
                .setDescription(`Votre participation au loto a √©t√© enregistr√©e`),
        alreadyParticipate: (user: User, guild: Guild) =>
            userMember(user)
                .setColor(evokerColor(guild))
                .setTitle('Participation d√©j√† enregistr√©e')
                .setDescription(`Vous participez d√©j√† au loto`),
        noParticipation: (user: User, guild: Guild) =>
            userMember(user)
                .setColor(evokerColor(guild))
                .setTitle('Participation non enregistr√©e')
                .setDescription(`Vous ne participez pas au loto sur ce serveur`),
        participationDeleted: (user: User) =>
            userMember(user)
                .setColor(util<ColorResolvable>('accentColor'))
                .setTitle('Participation retir√©e')
                .setDescription(`Votre participation au loto a √©t√© annul√©e`),
        lotoDeleted: (user: User) =>
            userMember(user)
                .setColor(util<ColorResolvable>('accentColor'))
                .setTitle('Loto supprim√©')
                .setDescription(`Le loto a √©t√© annul√© sur le serveur`),
        lotoStarted: (user: User, data: { coins: number; complementaries: number; numbers: number; endsAt: number }) =>
            userMember(user)
                .setColor(util<ColorResolvable>('accentColor'))
                .setTitle('Loto')
                .setDescription(
                    `Un loto a √©t√© lanc√© par ${pingUser(
                        user
                    )} !\nPour participer, utilisez la commande \`/loto participer\`\n\nModalit√©s :\n* ${numerize(
                        data.numbers
                    )} num√©ros gagnants n√©cessaires\n* ${numerize(data.complementaries)} num√©ro${plurial(
                        data.complementaries
                    )} compl√©mentaire${plurial(data.complementaries)} n√©cessaires\n* Se finit ${displayDate(
                        data.endsAt
                    )}${
                        data.coins > 0
                            ? `\n* ${numerize(data.coins)} ${util('coins')} sont en jeu √† partager entre les gagnants`
                            : ''
                    }`
                )
                .setTimestamp(data.endsAt),
        invalidParticipation: (user: User, guild: Guild, data: { numbers: number; complementaries: number }) => {
            const numbers: number[] = [];
            const complementaries: number[] = [];

            const available: number[] = [];
            for (let i = 1; i < 100; i++) {
                available.push(i);
            }

            for (let i = 0; i < data.numbers; i++) {
                const int = available[random({ max: available.length })];
                numbers.push(int);

                available.splice(available.indexOf(int), 1);
            }
            for (let i = 0; i < data.complementaries; i++) {
                const int = available[random({ max: available.length })];
                complementaries.push(int);

                available.splice(available.indexOf(int, 1));
            }
            return userMember(user)
                .setColor(evokerColor(guild))
                .setTitle('Participation invalide')
                .setDescription(
                    `Votre participation est invalide.\nVous devez sp√©cifier **${
                        data.numbers
                    }** num√©ros gagnants, et **${data.complementaries}** num√©ro${plurial(
                        data.complementaries
                    )} compl√©mentaire${plurial(
                        data.complementaries
                    )} tous diff√©rents\n\nPar exemple :\n* Num√©ros gagnants : \`${numbers.join(' ')}\`${
                        data.complementaries > 0
                            ? `\n* Num√©ro${plurial(data.complementaries)} compl√©mentaire${plurial(
                                  data.complementaries
                              )} : \`${complementaries.join(' ')}\``
                            : ''
                    }`
                );
        },
        lotoAlreadyStarted: (user: User, guild: Guild) =>
            userMember(user)
                .setColor(evokerColor(guild))
                .setTitle('Loto d√©j√† lanc√©')
                .setDescription(`Un loto existe d√©j√† sur ${guild.name}`),
        lotoResult: (
            user: User,
            rolled: { numbers: number[]; complementaries: number[] },
            winners: {
                userId: string;
                numbers: number[];
                complementaries: number[];
                accuracy: number;
                reward: number;
            }[]
        ) => {
            if (winners.length == 0)
                return userMember(user, util<ColorResolvable>('accentColor'))
                    .setTitle('R√©sultats du loto')
                    .setDescription(
                        `Num√©ros tir√©s :\n* Gagnants : \`${rolled.numbers.join(' ')}\`${
                            rolled.complementaries.length > 0
                                ? `\n* Compl√©mentaire${plurial(
                                      rolled.complementaries
                                  )} : \`${rolled.complementaries.join(' ')}\``
                                : ''
                        }\n\nIl n'y a aucun gagnant pour ce loto`
                    );
            return userMember(user, util<ColorResolvable>('accentColor'))
                .setTitle('R√©sultats du loto')
                .setDescription(
                    `Num√©ros tir√©s :\n* Gagnants : \`${rolled.numbers.join(' ')}\`${
                        rolled.complementaries.length > 0
                            ? `\n* Compl√©mentaire${plurial(rolled.complementaries)} : \`${rolled.complementaries.join(
                                  ' '
                              )}\``
                            : ''
                    }\n\nGagnants : ${winners
                        .map(
                            (w) =>
                                `${pingUser(w.userId)} avec ${w.accuracy * 100}% de pr√©cision ( ${w.reward} ${util(
                                    'coins'
                                )} )`
                        )
                        .join('\n')}`
                );
        }
    },
    internalError: (user: anyUser) =>
        userMember(user)
            .setTitle('Erreur interne')
            .setDescription(
                `Une erreur interne est survenue.\nVeuillez r√©eesayer. Si l'erreur persiste, contactez mon [serveur de support](${util(
                    'support'
                )})`
            ),
    pollEmbed: (
        user: User,
        question: string,
        endsAt: number,
        choices: { name: string; count: number; id?: number }[]
    ) =>
        userMember(user, util<ColorResolvable>('accentColor'))
            .setTitle('Sondage')
            .setDescription(
                `Sondage lanc√© par ${pingUser(user)}\n> ${question}\n\n${choices
                    .map((x) => `${x.name} ( ${x.count} vote${plurial(x.count)} )`)
                    .join('\n')}`
            )
            .addFields({ name: 'Fin', value: displayDate(endsAt), inline: false }),
    tasks: {
        pending: (data: tasks) => {
            const embed = new EmbedBuilder()
                .setTitle(resizeString({ str: data.name, length: 256 }))
                .setDescription(
                    resizeString({
                        str: `T√¢che en attente\n${data.description}\n\nAssignez-vous pour commencer la t√¢che`,
                        length: 4096
                    })
                )
                .setFields({ name: 'Ouvert par', value: pingUser(data.opened_by) ?? 'inconnu', inline: true })
                .setColor(color('taskPending'))
                .setTimestamp(data.startedAt);

            if (notNull(data.deadline) && data.deadline > 0)
                embed.addFields({
                    name: '√Ä faire avant',
                    value: displayDate(data.deadline) ?? 'Inconnu',
                    inline: true
                });
            if (notNull(data.image)) embed.setImage(data.image);
            return embed;
        },
        working: (data: tasks) => {
            const embed = new EmbedBuilder()
                .setTitle(resizeString({ str: data.name, length: 256 }))
                .setDescription(resizeString({ str: `T√¢che en cours\n${data.description}`, length: 4096 }))
                .setFields({ name: 'Ouvert par', value: pingUser(data.opened_by), inline: true })
                .setColor(color('taskWorking'))
                .setTimestamp(data.startedAt);

            if (notNull(data.deadline) && data.deadline > 0)
                embed.addFields({ name: '√Ä faire avant', value: displayDate(data.deadline), inline: true });
            if (notNull(data.image)) embed.setImage(data.image);

            embed.addFields({
                name: 'Assign√©' + plurial(data.assignees),
                value: data.assignees.length === 0 ? 'Aucun assign√©' : data.assignees.map(pingUser).join(', '),
                inline: false
            });

            return embed;
        },
        closed: (data: tasks, reason: 'deadline crossed' | 'someone closed') => {
            const embed = new EmbedBuilder()
                .setTitle(resizeString({ str: data.name, length: 256 }))
                .setDescription(resizeString({ str: `T√¢che ferm√©e\n${data.description}`, length: 4096 }))
                .setTimestamp()
                .setColor(color('taskClosed'))
                .setFields({
                    name: 'Informations',
                    value:
                        reason === 'deadline crossed' ? `La date limite a √©t√© atteinte` : `Quelqu'un a ferm√© la t√¢che`,
                    inline: false
                });
            if (notNull(data.image)) embed.setImage(data.image);

            return embed;
        },
        done: (data: tasks) => {
            const embed = new EmbedBuilder()
                .setTitle(resizeString({ str: data.name, length: 256 }))
                .setDescription(resizeString({ str: `La t√¢che a √©t√© termin√©e\n${data.description}`, length: 4096 }))
                .setTimestamp()
                .setColor(color('taskDone'));

            if (notNull(data.image)) embed.setImage(data.image);

            return embed;
        },
        unexisting: (user: anyUser) =>
            userMember(user).setTitle('T√¢che inexistante').setDescription(`Cette t√¢che n'existe pas`),
        taskEnded: (user: anyUser) =>
            userMember(user)
                .setTitle('T√¢che termin√©e')
                .setDescription(`Cette t√¢che est termin√©e, vous ne pouvez pas assigner quelqu'un`)
    },
    invalidEmoji: (user: anyUser) =>
        userMember(user)
            .setTitle('√âmoji invalide')
            .setDescription(
                `Ce n'est pas un √©moji valide.\nVeuillez envoyer un √©moji correct, et assurez-vous que je puisse acc√©der √† cet √©moji`
            ),
    requestStopped: (user: anyUser) =>
        userMember(user)
            .setTitle('Erreur')
            .setDescription(
                `Les donn√©es n'ont pas pu √™tre trouv√©es √† cause d'un probl√®me venant de la plateforme.\nPatientez quelques minutes, puis r√©essayez.\nSi cette erreur persiste, contactez le d√©veloppeur, par le [serveur de support](${util(
                    'support'
                )}) ou par l'adresse email ( \`${util('email')}\` )`
            ),
    invalidChannel: (user: anyUser) =>
        userMember(user)
            .setTitle('Salon invalide')
            .setDescription(`Ce n'est pas un salon valide, r√©essayez avec un nom, un identifiant ou une mention`),
    invalidChannelType: (user: anyUser, types: ChannelType[]) => {
        const vals: Record<ChannelType, string> = {
            10: "fil d'annonce",
            1: 'messages priv√©s',
            3: 'groupe priv√©',
            5: 'annonces',
            4: 'cat√©gorie',
            14: 'cat√©gorie',
            15: 'forum',
            12: 'fil priv√©',
            11: 'fil public',
            13: 'conf√©rences',
            0: 'textuel',
            2: 'vocal'
        };

        return userMember(user)
            .setTitle('Type de salon invalide')
            .setDescription(
                `Ce n'est pas un salon valide, veuillez sp√©cifier un salon de type : ${types
                    .map((x) => vals[x])
                    .join(', ')}`
            );
    },
    configDisabled: (user: anyUser, config: keyof configKeys) =>
        userMember(user)
            .setTitle('Param√®tre d√©sactiv√©')
            .setDescription(`Le param√®tre **${configsData[config].name}** est d√©sactiv√©`)
};

export type replyKey = keyof typeof replies;

export default replies;
